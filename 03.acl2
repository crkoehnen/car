
;; 3.10
(defun fib (n)
  (cond
   ((zp n) 1)
   ((= n 1) 1)
   (t
    (+ (fib (- n 1))
       (fib (- n 2))))))

;; 3.11
(defun pascal (i j)
  (cond ((not (and (integerp i) (integerp j))) 0)
        ((= i j) 1)
        ((< i j) 0)
        ((= j 0) 1)
        ((< i 0) 0)
        ((< j 0) 0)
        (t (+ (pascal (- i 1) (- j 1))
              (pascal (- i 1) j)))))



(defun mem (e x)
  (if (endp x)
      nil
    (if (equal e (car x))
        t
      (mem e (cdr x)))))

;; 3.12
(defun subset (x y)
  (cond ((endp x) t)
        ((mem (car x) y) (subset (cdr x) y))
        (t nil)))

;; 3.13
(defun dedup (in out)
  (cond ((and (atom out) (not (null out))) '())
        ((endp in) out)
        ((mem (car in) out) (dedup (cdr in) out))
        (t (dedup (cdr in) (cons (car in) out)))))

(defun un (x y)
  (dedup (append x y) '()))

;; 3.14
(defun int (x y)
  (cond ((endp x) '())
        ((mem (car x) y) (cons (car x) (int (cdr x) y)))
        (t (int (cdr x) y))))

;; 3.15
(defun diff (x y)
  (cond ((endp x) '())
        ((mem (car x) y) (diff (cdr x) y))
        (t (cons (car x) (diff (cdr x) y)))))

;; 3.16
(defun rev (x)
  (if (endp x)
      '()
    (append (rev (cdr x)) (list (car x)))))

;; 3.17
(defun insert (i l)
  (cond ((endp l) (list i))
        ((<= i (car l)) (cons i l))
        (t (cons (car l) (insert i (cdr l))))))

(defun isort (l)
  (if (endp l)
      '()
    (let ((tail (isort (cdr l))))
      (insert (car l) tail))))